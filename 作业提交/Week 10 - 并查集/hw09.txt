第9次作业要求：

部分术语：本*作业要求*中所使用的部分术语的简单注释说明。
          1. 本说明通常用 N 表示数据集的规模
          2. 本说明的“集合”、“数据集”指 { 0,1,...,N-1 }
          3. 用例 - 应用场景案例

-----------------------------------------------------------------------------------------
任务一：
-----------------------------------------------------------------------------------------
目    的：建立 不相交集类 的C++类 - 基于C++11语言规范标准
          为简单起见，以下用 幷查集 来指代上述数据结构

类 型 名：disjset 或 djset (建议)
          为简单起见，以下用 DSET 来指代上述类型名

基本架构：
          1. 构造函数
             (1) 普通构造 DSET(unsigned long N);
                 初始化有 N 个元素的数据集的不相交集类
             (2) 复制构造 DSET(const DSET&);
             (3) 移动构造 DSET(DSET&&);
             (4) 初始化表构造 (建议)
                 用例：
                 HASH<T> s = { {1,2}, {3,4}, {3,5} };
                 定义有 5 个元素的幷查集 s，元素关系由初始化列表给出
                 得到的等价类分别为 { 1,2 }, { 3,4,5 }
                 注：可能需要定义辅助“点对”类型
          2. 析构函数
          3. 赋值运算重载
             (1) 复制赋值 DSET& operator=(const DSET&);
             (2) 移动赋值 DSET& operator=(DSET&&);
             (3) 初始化表赋值 (建议)
          4. 基本函数
             (1) size_type size () const;
                 返回指定幷查集的元素个数
             (2) void clear();
                 将当前幷查集重设为初始状态

功能要求：提供查找以及合并等价类基本功能
          1. 查找函数：返回元素 x 所在等价类的代表元
             (1) int find(int x) const;
                 不支持路径压缩
             (2) int find(int x);
                 支持路径压缩
          2. 合并函数：合并包含 x 的等价类和包含 y 的等价类
             (1) void merge(int x, int y);
                 建议：如果 x, y 不是根(等价类代表元)，则先确定相应代表元
          3. 交换函数：交换两个幷查集类的对象
             (1) void swap(DSET& rhs);

建议：其它可能有益于应用的功能

性能要求：各种操作符合指定的时间复杂度。
          1. 移动构造/移动赋值/size/swap                - O(1)
          2. 默认构造/复制构造/初始化表构造             - O(参数对象包含的元素个数)
          3. 复制赋值/初始化表赋值                      - O(参数对象包含的元素个数)
          4. 查找/合并                                  - O(log*N)

测试要求：检查所实现 DSET类 的对象是否具备上述要求的功能和性能。

-----------------------------------------------------------------------------------------
任务二：实现 “计算无向图的连通分支” 算法
-----------------------------------------------------------------------------------------
目    的：对于给定标号为 1, 2, ..., N 的 N 个顶点的无向图，计算其所有连通分支。

数据规格：
 1. 输入：输入数据由两部分组成
          第一部分包含两个非负整数 N、M，其中 N 为给定无向图顶点个数，M 为无向图的边数
          第二部分有 M 对不超过 N 的正整数 x、y，表示顶点 x 与顶点 y 之间有边
 2. 输出：对于给定的输入数据，输出 k 行正整数，k 是给定无向图的连通分支数
          每行的正整数是一个连通分支的顶点标号，这些整数之间由一个空格分隔

数据样例：
 1. 输入:

5 3
1 2 3 4 3 5

 2. 输出：(注意，输出不唯一)

1 2
3 4 5

-----------------------------------------------------------------------------------------
任务三：实现 “Kruskal” 算法
-----------------------------------------------------------------------------------------
目    的：对于给定标号为 1, 2, ..., N 的 N 个顶点的边赋权无向连通图，计算其最小生成树。

数据规格：
 1. 输入：输入数据由两部分组成
          第一部分包含两个非负整数 N、M，其中 N 为给定无向图顶点个数，M 为无向图的边数
          第二部分有 M 个三元组 x、y、w，表示顶点 x 与顶点 y 之间有带实数权 w 的边
 2. 输出：对于给定的输入数据，输出 N 行，第一行为一个实数，表示最小生成树边权的和，第二
          到第 N 行为两个正整数，表示最小生成树的所有边

数据样例：
 1. 输入:

7 12
1 2 2
1 4 1
1 3 4
2 4 3
2 5 10
3 4 2
3 6 5
4 5 7
4 6 8
4 7 4
5 7 6
6 7 1

 2. 输出：(注意，输出不唯一)

16
1 4
6 7
1 2

3 4
4 7
5 7


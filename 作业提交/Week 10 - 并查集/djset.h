#ifndef DISJ_SETS_H
#define DISJ_SETS_H

#include<vector>
#include<cstdio>
using namespace std;
class djset
{
private:
    // fa[i] 用于记录节点i的祖先
    vector<int> fa;

public: /************ 基本架构 **************/

/*****************************************
 * (1)普通构造函数
 * 初始化有N个元素的不相交集类
 * *************************************/
    explicit djset(unsigned long N):fa(N)
    {
        // 初始阶段,所有元素的祖先都是他自己.
        for(int i=0 ; i<N ; i++)
            fa[i] = i;
    }

/*****************************************
 * (2)复制构造函数
 * *************************************/
    djset(const djset& rhs):fa(rhs.fa.size())
    {
        for(int i=0 ; i<rhs.fa.size() ; i++)
            fa[i] = rhs.fa[i];
    }
/*****************************************
 * (2)移动构造函数
 * *************************************/
    djset(djset&& rhs):fa(rhs.fa.size())
    {
        fa = std::move(rhs.fa);
    }

/********************************************
 * 析构函数
 *******************************************/
    ~djset()
    {
        fa.clear();
    }

/********************************************
 * 复制赋值重载
 *******************************************/
    djset& operator=(const djset& rhs)
    {
        for(int i=0 ;i<rhs.fa.size() ; i++)
            fa[i] = rhs.fa[i];
    }
/********************************************
 * 移动赋值重载
 *******************************************/
    djset& operator=(djset&& rhs)
    {
        fa = std::move(rhs.fa);
    }

/********************************************
 * 基本函数：查询并查集的元素个数
 *******************************************/
    unsigned long size() const
        {return fa.size();}
/********************************************
 * 基本函数：将并查集重设为初始状态
 *******************************************/
    void clear()
    {
        fa.clear();
    }

public: /************* 功能要求 *************/

/*****************************************
 * 关系查询:不支持压缩路径
 * **************************************/
    int find(int x) const
    {
        if(fa[x] == x)
            return x;
        else
            return find(fa[x]);
    }

/*****************************************
 * 关系查询:支持压缩路径
 * **************************************/
    int find(int x)
    {
        if(fa[x] == x)
            return x;
        else
            return fa[x] = find(fa[x]);
    }


/*****************************************
 * 集合合并
 * 合并包含a,b的等价类
 * ***************************************/
    void unionSets(int a, int b)
    {
        fa[a] = find(a);
        fa[b] = find(b);
        if(fa[a] < fa[b])
        {
            fa[fa[b]] = fa[a];
            fa[b] = find(b);
        }
            
        else if(fa[b] < fa[a])
        {
            fa[fa[a]] = fa[b];
            fa[a] = find(a);
        }
            
    }

/******************************************
 * 交换函数
 * 交换两个并查集类的对象
 * ****************************************/
    void swap(djset& rhs)
    {
        vector<int> tmp = fa;
        fa = rhs.fa;
        rhs.fa = tmp;
        tmp.clear();
    }

/******************************************
 * 查看关系
 * ****************************************/
    void print_father()
    {
        for(int i=0 ; i<fa.size() ; i++)
            printf("%d ----- %d\n",i,find(i));
    }

};



#endif










































/*
-----------------------------------------------------------------------------------------
任务一：
-----------------------------------------------------------------------------------------
目    的：建立 不相交集类 的C++类 - 基于C++11语言规范标准
          为简单起见，以下用 幷查集 来指代上述数据结构

类 型 名：disjset 或 djset (建议)
          为简单起见，以下用 DSET 来指代上述类型名

基本架构：
          1. 构造函数
             (1) 普通构造 DSET(unsigned long N);
                 初始化有 N 个元素的数据集的不相交集类
             (2) 复制构造 DSET(const DSET&);
             (3) 移动构造 DSET(DSET&&);
             (4) 初始化表构造 (建议)
                 用例：
                 HASH<T> s = { {1,2}, {3,4}, {3,5} };
                 定义有 5 个元素的幷查集 s，元素关系由初始化列表给出
                 得到的等价类分别为 { 1,2 }, { 3,4,5 }
                 注：可能需要定义辅助“点对”类型
          2. 析构函数
          3. 赋值运算重载
             (1) 复制赋值 DSET& operator=(const DSET&);
             (2) 移动赋值 DSET& operator=(DSET&&);
             (3) 初始化表赋值 (建议)
          4. 基本函数
             (1) size_type size () const;
                 返回指定幷查集的元素个数
             (2) void clear();
                 将当前幷查集重设为初始状态

功能要求：提供查找以及合并等价类基本功能
          1. 查找函数：返回元素 x 所在等价类的代表元
             (1) int find(int x) const;
                 不支持路径压缩
             (2) int find(int x);
                 支持路径压缩
          2. 合并函数：合并包含 x 的等价类和包含 y 的等价类
             (1) void merge(int x, int y);
                 建议：如果 x, y 不是根(等价类代表元)，则先确定相应代表元
          3. 交换函数：交换两个幷查集类的对象
             (1) void swap(DSET& rhs);

建议：其它可能有益于应用的功能

性能要求：各种操作符合指定的时间复杂度。
          1. 移动构造/移动赋值/size/swap                - O(1)
          2. 默认构造/复制构造/初始化表构造             - O(参数对象包含的元素个数)
          3. 复制赋值/初始化表赋值                      - O(参数对象包含的元素个数)
          4. 查找/合并                                  - O(log*N)

测试要求：检查所实现 DSET类 的对象是否具备上述要求的功能和性能。
*/
第5次作业要求：

部分术语：本*作业要求*中所使用的部分术语的简单注释说明。
          1. 本说明不严格区分”结点“与”结点数据域所包含的值“的称谓
          2. 在讨论时间复杂度问题时通常用 N 表示数据集的规模
          3. 用例 - 应用场景案例
          4. 邻近 - 与 x 的距离不超过某个给定常量(通常为2)的结点
                    被称为是与 x 邻近的
          5. 伸展 - 若 x 属于数据集，则将 x 转移至根结点，同时尽
                    可能多地保持其邻近结点的邻近性。

-----------------------------------------------------------------------------------------
任务一：
-----------------------------------------------------------------------------------------
目    的：建立伸展树的C++类 - 基于C++11语言规范标准

类 型 名：spltree (建议)

基本架构：
          1. 构造函数
             (1) 默认构造
                 用例1：spltree<T> b;
                 用例2: vector<spltree<T>> v(3);
                 用例3: spltree<T> a[3];
                 用例4: spltree<T>* p = spltree<T>[3];
             (2) 复制构造
                 用例1：spltree<T> b1;
                        ...
                        spltree<T> b2(b1);
                 用例2: void f(spltree<T> b) { ... }
                        ...
                        spltree<T> b;
                        ...
                        f(b);
             (3) 移动构造
                 用例1：spltree<T> b1;
                        ...
                        spltree<T> b2(std::move(b1));
                 用例2: spltree<T> f() { ... }
                        ...
                        spltree<T> b;
                        ...
                        b = f();
             (4) 初始化表构造
                 用例1：spltree<T> b = { ... };
                 用例2: void f(spltree<T> b) { ... }
                        ...
                        f({...});
          2. 析构函数
          3. 赋值运算重载
             (1) 复制赋值
                 用例1：spltree<T> b1, b2;
                        ...
                        b1 = b2;
             (2) 移动赋值
                 用例1：spltree<T> b1, b2;
                        ...
                        b1 = std::move(b2);
                 用例2: spltree<T> f() { ... }
                        ...
                        spltree<T> b;
                        ...
                        b = f();
             (3) 初始化表赋值
                 用例1：spltree<T> b;
                        ...
                        b = { ... };
          4. 基本函数
             (1) size_type size () const;
                 对于指定伸展树返回其结点个数
             (2) bool empty() const;
                 对于指定伸展树判定其是否为空树。
                 若肯定，返回true，否则返回false

功能要求：能够对一颗伸展树进行 查询/插入/删除 操作。
          1. 查询函数
             (1) bool contains(const value_type& x);
                 对于给定的值x，确定指定伸展树中是否存在结点其数据域的值
                 恰好与 x 的值相等(用集合论的术语，即：x 是否属于伸展树
                 所存储的数据集)。若回答肯定，返回true，否则返回false
                 此函数具有“伸展”副作用
             (2) const T& findmin() const; 或 const T& min() const;
                 对于指定伸展树返回其最小值
                 建议a：如果该伸展树为空树，则抛出异常
                 建议b：考虑此函数具有”伸展“副作用
             (3) T& findmin(); 或 T& min();
                 (同上)
             (4) const T& findmax() const; 或 const T& max() const;
                 对于指定伸展树返回其最大值
                 建议a：如果该伸展树为空树，则抛出异常
                 建议b：考虑此函数具有”伸展“副作用
             (5) T& findmax(); 或 T& max();
                 (同上)
          2. 插入函数: 在保持伸展树排序性的前提下将新元素加入其中。
             (1) bool insert(const T & );
             (2) bool insert(      T &&);
             如果确实有新元素加入，返回true，否则返回false
             建议：此函数在成功加入新元素的情况时*不*具有”伸展“副作用，
                   甚至完全不考虑其具有”伸展“副作用。
          3. 删除函数：对于给定元素，删除指定伸展树中等于此元素的结点
             (1) bool remove(const T&); 或 bool erase(const T&);
             如果确实有元素被删除，返回true，否则返回false
             建议a：如果该伸展树为空树，则抛出异常
             建议b：此函数在没有实际删除元素的情况时*不*具有”伸展“副作用，
                    甚至完全不考虑其具有”伸展“副作用。

性能要求：各种操作符合指定的时间复杂度。
          1. 默认构造/移动构造/移动赋值/基本函数         - O(1)
          2. 复制构造/复制赋值/初始化表构造/初始化表赋值 - O(参数对象包含的元素个数)
          3. 查询/插入/删除                              - O(logN)

测试要求：检查所实现spltree类的对象是否具备上述要求的功能和性能。

-----------------------------------------------------------------------------------------
任务二：
-----------------------------------------------------------------------------------------
目    的：二叉堆的C++类 - 基于C++11语言规范标准

类 型 名：bheap (建议)

基本架构：
          1. 构造函数
             (1) 默认构造
                 用例1：bheap<T> b;
                 用例2: vector<bheap<T>> v(3);
                 用例3: bheap<T> a[3];
                 用例4: bheap<T>* p = bheap<T>[3];
             (2) 序列构造 (建议)
                 用例1: T a[10];
                        ...
                        bheap<T> bp(a,a+10);
                 用例2: vector<T> a(10);
                        ...
                        bheap<T> bp(a.begin(),a.end());
                 用例3: list<T> a(10);
                        ...
                        bheap<T> bp(a.begin(),a.end());
             (3) 复制构造
                 用例1：bheap<T> b1;
                        ...
                        bheap<T> b2(b1);
                 用例2: void f(bheap<T> b) { ... }
                        ...
                        bheap<T> b;
                        ...
                        f(b);
             (4) 移动构造
                 用例1：bheap<T> b1;
                        ...
                        bheap<T> b2(std::move(b1));
                 用例2: bheap<T> f() { ... }
                        ...
                        bheap<T> b;
                        ...
                        b = f();
             (5) 初始化表构造
                 用例1：bheap<T> b = { ... };
                 用例2: void f(bheap<T> b) { ... }
                        ...
                        f({...});
          2. 析构函数
          3. 赋值运算重载
             (1) 复制赋值
                 用例1：bheap<T> b1, b2;
                        ...
                        b1 = b2;
             (2) 移动赋值
                 用例1：bheap<T> b1, b2;
                        ...
                        b1 = std::move(b2);
                 用例2: bheap<T> f() { ... }
                        ...
                        bheap<T> b;
                        ...
                        b = f();
             (3) 序列构造 (建议)
                 用例1: vector<T> a(10);
                        ...
                        bheap<T> bp;
                        ...
                        bp = a;
                 用例2: list<T> a(10);
                        ...
                        bheap<T> bp;
                        ...
                        bp = a;
             (4) 初始化表赋值
                 用例1：bheap<T> b;
                        ...
                        b = { ... };
          4. 基本函数
             (1) size_type size () const;
                 对于指定二叉堆返回其结点个数
             (2) bool empty() const;
                 对于指定二叉堆判定其是否为空堆。
                 若肯定，返回true，否则返回false

功能要求：能够对一个给定的二叉堆进行*查询/插入/删除*操作。
          1. 查询函数
             (1) const T& findmin() const; 或
                 const T& min() const; 或
                 const T& top() const;
                 对于指定二叉堆返回其最小值
                 建议：如果该二叉堆为空堆，则抛出异常
             (2) T& findmin(); 或 T& min(); 或 T& top();
                 (同上)
          2. 插入函数: 在保持二叉堆堆序性的前提下将新元素加入其中。
             (1) void insert(const T&  x); 或 void push(const T&  x);
             (2) void insert(      T&& x);    void push(      T&& x);
          3. 删除函数：删除指定二叉堆的最小元
             (1) void delmin(    ); 或 void pop();
             (2) void delmin(T& x); 或 void pop(T&);
             建议：不考虑空堆异常情况
          4. 其它函数：
             (1) void buildheap();
                 对于存储于向量中下标位于区间[1,size()]的数据，按完全二叉
                 树逻辑结构建立堆序
      (建议) (2) void swap(bheap<T>&);
                 交换当前二叉堆与参数指定的二叉堆
      (建议) (3) void keydec(size_type ndx, const T& d);
                 对于存储于向量中下标为 ndx 的数据减小 d，并调整其堆序关系
      (建议) (4) void keyinc(size_type ndx, const T& d);
                 对于存储于向量中下标为 ndx 的数据增加 d，并调整其堆序关系
      (建议) (5) void remove(size_type ndx);
                 删除存储于向量中下标为 ndx 的数据并保持堆序关系不被破坏

性能要求：各种操作符合指定的时间复杂度。
          1. 默认构造/移动构造/移动赋值/基本函数/查询/swap  - O(1)
          2. 序列构造/序列赋值                              - O(序列长度)
          3. 复制构造/复制赋值/初始化表构造/初始化表赋值    - O(参数对象包含的元素个数)
          4. 插入/删除/keydec/keyinc/remove                 - O(N)
          5. buildheap                                      - O(NlogN)

测试要求：检查所实现bheap类的对象是否具备上述要求的功能和性能。

